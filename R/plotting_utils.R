# Utilities for plotting

# Specific plotting helpers -----

#' Plot the mean distance to k-nearest neighbors.
#'
#' @description
#' Plots the sorted (ascending) distances to k-nearest neighbors
#' (kNN) for each observation in the provided dissimilarity object.
#'
#' @details
#' Internally, the mean kNN distances are calculated with the
#' \code{\link[dbscan]{kNNdist}} function.
#'
#' @references
#' Hahsler M, Piekenbrock M, Doran D. Dbscan: Fast density-based clustering
#' with R. J Stat Softw (2019) 91:1–30. doi:10.18637/jss.v091.i01
#' @references
#' Belyadi H, Haghighat A, Nguyen H, Guerin A-J. IOP Conference Series:
#' Earth and Environmental Science Determination of Optimal Epsilon (Eps)
#' Value on DBSCAN Algorithm to Clustering Data on Peatland Hotspots in
#' Sumatra Related content EPS conference comes to London-EPS rewards
#' quasiparticle research-EP. IOP Conf Ser Earth Environ Sci (2016) 31:
#' doi:10.1088/1755-1315/31/1/012012
#'
#' @return A ggplot object.
#'
#' @param diss_obj a dissimilarity object (e.g. 'dist' class).
#' @param k the k number of the nearest neighbors.
#' @param eps the distance to be presented in the plot as a horizontal dashed
#' line. If NULL, the line is hidden.
#' @param plot_title plot title.
#' @param plot_subtitle plot subtitle.
#' @param plot_tag plot tag.
#' @param cust_theme custom plot theme, a ggplot2 theme object.

  plot_knn_distance <- function(diss_obj,
                                k,
                                eps = NULL,
                                plot_title = NULL,
                                plot_subtitle = NULL,
                                plot_tag = NULL,
                                cust_theme = ggplot2::theme_classic()) {

    stopifnot(inherits(diss_obj, 'dist'))
    stopifnot(inherits(cust_theme, 'theme'))

    point <- NULL
    knn_dist <- NULL

    sort_distances <- dbscan::kNNdist(x = diss_obj,
                                      k = k,
                                      all = FALSE)

    sort_distances <- sort(sort_distances)

    sort_distances <-
      tibble(sample = names(sort_distances),
             knn_dist = unname(sort_distances),
             point = 1:length(sort_distances))

    dist_plot <- ggplot(data = sort_distances,
                        aes(x = point,
                            y = knn_dist)) +
      ggplot2::geom_area(color = 'cornsilk4',
                         fill = 'cornsilk2') +
      cust_theme +
      ggplot2::labs(x = 'Sample',
                    y = paste(k, 'NN distance', sep = '-'),
                    title = plot_title,
                    subtitle = plot_subtitle,
                    tag = plot_tag)

    if(!is.null(eps)) {

      dist_plot <- dist_plot +
        ggplot2::geom_hline(yintercept = eps,
                            linetype = 'dashed',
                            color = 'black')

    }

    dist_plot

  }

#' Plot a dendrogram.
#'
#' @description
#' Plots a dendrogram given a clustering object generated by
#' \code{\link[stats]{hclust}}.
#'
#' @details
#' The dendrogram structure is generated with the
#' \code{\link[stats]{as.dendrogram}} function and graphical layout provided
#' by \code{\link[dendextend]{color_branches}} and
#' \code{\link[dendextend]{set}}.
#'
#' @references
#' Galili T. dendextend: an R package for visualizing, adjusting and
#' comparing trees of hierarchical clustering. Bioinformatics (2015) 31:3718–20.
#' doi:10.1093/bioinformatics/btv428
#'
#' @return A ggplot object.
#'
#' @param clust_str an object of the 'hclust' class.
#' @param k an integer, the cluster number.
#' @param labels logical, should observation labels be presented in the x axis?
#' @param cluster_colors colors of the cluster branches, a vector of the length
#' k + 1. The last color codes for the connector branches.
#' @param cluster_labels cluster names, a text vector of the lenght k.
#' @param cluster_leg_title cluster legend title.
#' @param plot_title plot title.
#' @param plot_subtitle plot subtitle.
#' @param plot_tag plot tag.
#' @param y_lab y axis title.
#' @param cust_theme custom plot theme, a ggplot2 theme object.
#' @param ... extra arguments, currently none.

  plot_dendro <- function(clust_str,
                          k,
                          labels = TRUE,
                          cluster_colors = NULL,
                          cluster_labels = paste0('Cluster #', 1:k),
                          cluster_leg_title = 'Cluster',
                          plot_title = NULL,
                          plot_subtitle = NULL,
                          plot_tag = NULL,
                          y_lab = NULL,
                          cust_theme = ggplot2:: theme_classic(), ...) {

    ## entry control

    stopifnot(inherits(clust_str, 'hclust'))
    stopifnot(is.logical(labels))
    stopifnot(inherits(cust_theme, 'theme'))

    k <- as.integer(k)

    ## dendrogram data

    dendro_data <- stats::as.dendrogram(clust_str)

    dendro_data <- dendextend::color_branches(dend = dendro_data, k = k)

    dendro_data <- dendextend::set(dend = dendro_data,
                                   'branches_lwd', 0.5)

    dendro_data <- dendextend::set(dend = dendro_data,
                                   'labels_cex', 0.5)

    ## plotting

    dendro_plot <- ggplot2::ggplot(data = dendro_data,
                                   labels = labels) +
      cust_theme +
      ggplot2::theme(axis.line.x = ggplot2::element_blank(),
                     axis.text.x = ggplot2::element_blank(),
                     axis.ticks.x = ggplot2::element_blank(),
                     axis.title.x = ggplot2::element_blank()) +
      ggplot2::labs(title = plot_title,
                    subtitle = plot_subtitle,
                    tag = plot_tag,
                    y = y_lab)

    if(all(c(!is.null(cluster_colors),
             !is.null(cluster_labels),
             !is.null(cluster_leg_title)))) {

      suppressMessages(dendro_plot <- dendro_plot +
                         ggplot2::scale_color_manual(values = cluster_colors,
                                                     labels = cluster_labels,
                                                     name = cluster_leg_title) +
                         ggplot2::guides(color = ggplot2::guide_legend()))

    }

    dendro_plot

  }

#' Plot WSS curve and silhouette statistic values as a function of cluster
#' number.
#'
#' @description
#' Plots the values of the total within-cluster sum-of-squares and
#' silhouette statistic as a function of the cluster number.
#'
#' @details
#' Takes a distance matrix (e.g. the \code{\link{get_kernel_info}}
#' output) and a clustering function, for the details, see:
#' \code{\link[factoextra]{fviz_nbclust}}.
#'
#' @return a ggplot object.
#'
#' @references
#' Kassambara A, Mundt F. factoextra: Extract and Visualize the Results
#' of Multivariate Data Analyses. (2020) Available at:
#' https://cran.r-project.org/web/packages/factoextra/index.html
#' @references
#' Rousseeuw PJ. Silhouettes: A graphical aid to the interpretation and
#' validation of cluster analysis. J Comput Appl Math (1987) 20:53–65.
#' doi:10.1016/0377-0427(87)90125-7
#'
#' @param data a numeric matrix with the distances or a data frame.
#' @param k an integer, the cluster number.
#' @param FUNcluster a clustering function. See:
#' \code{\link[factoextra]{fviz_nbclust}} for details.
#' @param method a statistic to be plotted. See:
#' \code{\link[factoextra]{fviz_nbclust}} for details.
#' @param plot_title plot title.
#' @param plot_subtitle plot subtitle.
#' @param plot_tag plot tag.
#' @param cust_theme custom plot theme, a ggplot2 theme object.
#' @param ... extra arguments passed to \code{\link[factoextra]{fviz_nbclust}}.
#'
#' @export

  plot_nbclust <- function(data,
                           k,
                           FUNcluster = NULL,
                           method = c('wss', 'silhouette', 'gap_stat'),
                           plot_title = NULL,
                           plot_subtitle = NULL,
                           plot_tag = NULL,
                           cust_theme = ggplot2::theme_classic(), ...) {

    ## entry control

    check_numeric(data)

    stopifnot(inherits(cust_theme, 'theme'))

    k <- as.integer(k)

    method <- match.arg(method[1],
                        c('silhouette', 'wss', 'gap_stat'))

    ## plotting

    factoextra::fviz_nbclust(data,
                             FUNcluster = FUNcluster,
                             method = method, ...) +
      ggplot2::geom_vline(xintercept = k,
                          linetype = 'dashed',
                          color = 'coral3') +
      cust_theme +
      ggplot2::labs(title = plot_title,
                    subtitle = plot_subtitle,
                    tag = plot_tag)

  }

# Plots for SOM -------

#' Plot diagnostic plots for the self-organizing map.
#'
#' @description
#' Generates a set of diagnostic plots for the 'kohonen' class
#' object as specified by \code{\link[kohonen]{plot.kohonen}}.
#'
#' @references
#' Wehrens R, Kruisselbrink J. Flexible self-organizing maps in kohonen 3.0.
#' J Stat Softw (2018) 87:1–18. doi:10.18637/jss.v087.i07
#'
#' @return  If `base_plots` is set to false, a list of non-editable ggplot
#' objects is returned.
#'
#' @param kohonen_object a 'kohonen' class object.
#' See: \code{\link[kohonen]{som}} for details.

  plot_som <- function(kohonen_object) {

    ## generates diagnostic plots for the test cohort

    stopifnot(inherits(kohonen_object, 'kohonen'))

    if(!rlang::is_attached('package:kohonen')) {

      warning(paste("To generate SOM diagnostic plots, please",
                    "load the 'kohonen' package first"),
              call. = FALSE)

      return(NULL)

    }

    plot_methods <- c('change',
                      'codes',
                      'counts',
                      'mapping',
                      'dist.neighbours',
                      'quality')

    plot_exprs <- rlang::enexpr(kohonen_object)

    plot_exprs_lst <- purrr::map(plot_methods,
                                 function(x) rlang::expr(~plot(!!plot_exprs,
                                                               !!x)))

    plot_exprs_lst <- rlang::set_names(plot_exprs_lst,
                                       plot_methods)

    purrr::map(plot_exprs_lst,
               function(x)
                 cowplot::ggdraw(cowplot::as_grob(rlang::eval_tidy(x))))

  }

#' Visualize the SOM training process.
#'
#' @description
#' Plots the mean distance to the neuron/winning unit as a
#' function of the iteration number.
#'
#' @references
#' Wehrens R, Kruisselbrink J. Flexible self-organizing maps in kohonen 3.0.
#' J Stat Softw (2018) 87:1–18. doi:10.18637/jss.v087.i07
#'
#' @return a ggplot object.
#'
#' @param kohonen_object a 'kohonen' class object.
#' @param plot_title plot title.
#' @param plot_subtitle plot subtitle.
#' @param cust_theme custom plot theme, a ggplot2 theme object.
#' @param ... extra arguments, currently none specified.

  plot_train_som <- function(kohonen_object,
                             plot_title = NULL,
                             plot_subtitle = NULL,
                             cust_theme = ggplot2::theme_classic(), ...) {

    ## plots the distance to the winning unit (neuron) during the training process
    ## a nicer plot using ggplot(). May pass additional arguments to the smoothing function

    stopifnot(inherits(kohonen_object, 'kohonen'))
    stopifnot(inherits(cust_theme, 'theme'))

    Iteration <- NULL

    change_data <- kohonen_object$changes

    if(is.null(colnames(change_data))) {

      new_names <- paste0('dist_', 1:ncol(change_data))

    } else {

      new_names <- colnames(change_data)

    }

    change_data <- as.data.frame(kohonen_object$changes)

    change_data <- rlang::set_names(change_data, new_names)

    change_data <- tibble::rownames_to_column(change_data, 'Iteration')

    n_iterations <- nrow(change_data)

    change_data <-
      tidyr::pivot_longer(change_data,
                          cols = all_of(new_names),
                          names_to = 'SOM layer',
                          values_to = 'dist')

    ggplot2::ggplot(change_data,
                    ggplot2::aes(x = as.numeric(Iteration),
                                 y = dist,
                                 color = .data[['SOM layer']])) +
      ggplot2::geom_point(shape = 16,
                          size = 1) +
      ggplot2::geom_smooth(method = 'loess',
                           se = FALSE, ...) +
      cust_theme +
      ggplot2::labs(x = 'Iteration',
                    y = 'Mean distance\nto the winning unit',
                    title = plot_title,
                    subtitle = plot_subtitle,
                    tag = paste0('\nIterations: n = ',
                                 n_iterations))

  }

# Diagnostic plots for HTK clustering -------

#' Generate diagnostic plots for hard threshold KMEANS clustering.
#'
#' @description
#' Creates the plot of within-cluster sum of squares and mean silhouette width
#' for the varying cluster numbers.
#'
#' @details
#' Corresponds to the output of \code{\link[factoextra]{fviz_nbclust}}.
#' Intended for internal use.
#'
#' @return a list of two elements `wss` and `silhouette` storing `ggplot`
#' objects with the plots of within-cluster sum of squares and silhouette widths.
#'
#' @param x a `clust_analysis` object.
#' @param k a numeric vector with the k cluster numbers. If `NULL`, it
#' will be determined automatically.
#' @param plot_title title of the plots.
#' @param plot_subtitle subtitle of the plots.
#' @param plot_tag plot tag.
#' @param cust_theme a custom `ggplot` theme.

  plot_htk <- function(x,
                       k = NULL,
                       plot_title = NULL,
                       plot_subtitle = NULL,
                       plot_tag = NULL,
                       cust_theme = ggplot2::theme_classic()) {

    ## input control -----

    stopifnot(is_clust_analysis(x))
    stopifnot(x$clust_fun == 'htk')
    stopifnot(inherits(cust_theme, 'theme'))

    ## determining the cluster number and the range of k ------

    clust_n <- nrow(ngroups(x))

    k_vec <- c(1:clust_n,
               (clust_n + 1):(clust_n + 6))

    ## fitting the clustering objects -------

    clust_calls <-
      map(k_vec,
          ~call2('htk_cluster',
                 data = model.frame(x),
                 k = .x,
                 lambdas = x$lambdas,
                 !!!compact(x$dots)))

    ## safely evaluate, for high cluster numbers
    ## an high lambda values, the algorithm may have no enough
    ## unique data points to initialize the centers

    clust_objects <- map(clust_calls, purrr::safely(eval))

    errors <- map(clust_objects, ~.x$error)

    correct <- map_lgl(errors, is.null)

    clust_objects <- compact(map(clust_objects, ~.x$result))

    ## stats --------

    variances <- map(clust_objects, var)

    variances <- map_dbl(variances, ~.x$total_wss)

    ## no point at computing silhouette for a single cluster
    ## its zero

    sil_w <- map(clust_objects[-1], silhouette)

    sil_w <- map_dbl(sil_w, ~mean(.x$sil_width))

    variance <- NULL
    silhouette <- NULL

    stats <- tibble(k = k_vec[correct],
                    variance = variances,
                    silhouette = c(0, sil_w))

    ## plots

    plots <-
      pmap(list(x = c('variance', 'silhouette'),
                y = c('Total Within Sum of Square',
                      'Average silhouette width')),
           function(x, y) ggplot(stats,
                                 aes(x = k,
                                     y = .data[[x]])) +
             ggplot2::geom_path(color = 'steelblue') +
             ggplot2::geom_point(shape = 16,
                                 size = 2,
                                 color = 'steelblue') +
             ggplot2::geom_vline(xintercept = clust_n,
                                 linetype = 'dashed',
                                 color = 'coral3') +
             ggplot2::scale_x_continuous(breaks = k_vec) +
             cust_theme +
             ggplot2::labs(title = plot_title,
                           subtitle = plot_subtitle,
                           tag = plot_tag,
                           y = y,
                           x = 'Number of clusters k'))

    set_names(plots, c('wss', 'silhouette'))

  }

# General plotting functions -------

#' Generate a custom scatter ggplot.
#'
#' @description
#' Generates a simple scatter ggplot.
#'
#' @return a ggplot object.
#'
#' @param data a data frame.
#' @param x_var the name of the variable to be presented in the x axis.
#' @param y_var the name of the variable to be presented in the y axis.
#' @param fill_var optional, the name of the variable coded by the point fill.
#' If NULL, the point fill is specified by the point_color argument.
#' @param label_var optional, the name of the variable to be presented in the
#' point labels. If NULL, no point labels are displayed.
#' @param plot_title plot title.
#' @param plot_subtitle plot subtitle.
#' @param plot_tag plot tag.
#' @param x_lab x axis title.
#' @param y_lab y axis title.
#' @param fill_lab fill legend title.
#' @param cust_theme custom plot theme, a ggplot2 theme object.
#' @param point_color point fill color.
#' @param point_alpha point alpha.
#' @param show_segments logical, should lines connecting the (0,0) point with
#' the plot point be displayed?
#' @param segment_color color of the connecting lines.
#' @param segment_alpha alpha of the connecting lines.
#' @param label_color color of the text labels.
#' @param txt_color color of the text presented in the labels.
#' @param txt_size size of the text presented in the labels.
#' @param txt_type type of the displayed text: either as geom_text or geom_label
#' @param jitter_width horizontal jittering of the points.
#' @param jitter_height vertical jittering of the points.

  plot_point <- function(data,
                         x_var,
                         y_var,
                         fill_var = NULL,
                         label_var = NULL,
                         plot_title = NULL,
                         plot_subtitle = NULL,
                         plot_tag = NULL,
                         x_lab = x_var,
                         y_lab = y_var,
                         fill_lab = NULL,
                         cust_theme = ggplot2::theme_classic(),
                         point_color = 'steelblue',
                         point_alpha = 1,
                         show_segments = FALSE,
                         segment_color = 'steelblue',
                         segment_alpha = 1,
                         label_color = point_color,
                         txt_color = 'black',
                         txt_size = 2.5,
                         txt_type = c('label', 'text'),
                         jitter_width = 0,
                         jitter_height = 0) {

    ## entry control

    stopifnot(is.data.frame(data))
    stopifnot(is.logical(show_segments))

    if(!x_var %in% names(data) | !y_var %in% names(data)) {

      stop('x_var or y_var absent from the data frame.', call. = FALSE)

    }

    if(!is.null(fill_var)) {

      if(!fill_var %in% names(data)) {

        stop('fill_var absent from the data frame.', call. = TRUE)

      }

    }

    if(!is.null(label_var)) {

      if(!label_var %in% names(data)) {

        stop('label_var absent from the data frame.', call. = TRUE)

      }

    }

    ## plotting

    if(is.null(fill_var)) {

      pplot <- ggplot(data = data,
                      aes(x = .data[[x_var]],
                          y = .data[[y_var]]))

    } else {

      pplot <- ggplot(data = data,
                      aes(x = .data[[x_var]],
                          y = .data[[y_var]],
                          fill = .data[[fill_var]]))

    }

    if(show_segments) {

      pplot <- pplot +
        ggplot2::geom_segment(ggplot2::aes(x = 0,
                                           y = 0,
                                           xend = .data[[x_var]],
                                           yend = .data[[y_var]]),
                              color = segment_color,
                              alpha = segment_alpha)

    }

    if(is.null(fill_var)) {

      pplot <- pplot +
        ggplot2::geom_point(shape = 21,
                            size = 2,
                            fill = point_color,
                            alpha = point_alpha,
                            position = ggplot2::position_jitter(width = jitter_width,
                                                                height = jitter_height))

    } else {

      pplot <- pplot +
        ggplot2::geom_point(shape = 21,
                            size = 2,
                            alpha = point_alpha,
                            position = ggplot2::position_jitter(width = jitter_width,
                                                                height = jitter_height))

    }

    if(!is.null(label_var)) {

      txt_type <- match.arg(txt_type[1], c('label', 'text'))

      if(txt_type == 'label') {

        pplot <- pplot +
          ggrepel::geom_label_repel(aes(label = .data[[label_var]]),
                                    size = txt_size,
                                    fill = label_color,
                                    color = txt_color,
                                    box.padding = 0.1,
                                    label.padding = 0.1)

      } else {

        pplot <- pplot +
          ggrepel::geom_text_repel(aes(label = .data[[label_var]]),
                                   size = txt_size,
                                   color = txt_color,
                                   box.padding = 0.1)

      }

    }

    pplot +
      cust_theme +
      ggplot2::labs(title = plot_title,
                    subtitle = plot_subtitle,
                    tag = plot_tag,
                    x = x_lab,
                    y = y_lab,
                    fill = fill_lab)


  }

# Clustering feature heat map -------

#' Plot clustering feature heat map.
#'
#' @description
#' Plotting of clustering features as a heat map (single layer analysis)
#' or a list of heat maps (multi-layer SOM). Intended for internal use.
#'
#' @param x_object a `clust_analysis` or `combi_analysis` object, specifies
#' clustering of the observations.
#' @param y_object a `clust_analysis` or `combi_analysis` object, specifies
#' clustering of the features, an optional parameter. Ignored in case of
#' multi-layer SOM.
#' @param line_color color of the line around heat map tiles.
#' @param discrete_fill logical, force a discrete fill scale?
#'
#' @return a `ggplot` object (single-layer analysis) or a list of
#' `ggplot` objects (multi-layer case).

  ft_hm_single <- function(x_object,
                           y_object,
                           line_color = NA,
                           discrete_fill = FALSE) {

    ## the entry control is made by an upstream function

    stopifnot(is.logical(discrete_fill))

    ## assignment list ---------

    cmm_assignment <- list()

    value <- NULL
    sample <- NULL
    feature <- NULL
    sample_node <- NULL

    cmm_assignment$sample <-
      select(extract(x_object, 'assignment'),
             dplyr::any_of(c('observation', 'node', 'clust_id')))

    if('node' %in% names(cmm_assignment$sample)) {

      cmm_assignment$sample <-
        set_names(cmm_assignment$sample,
                  c('sample', 'sample_node', 'sample_clust'))

    } else {

      cmm_assignment$sample <-
        set_names(cmm_assignment$sample,
                  c('sample', 'sample_clust'))

    }

    if(!is.null(y_object)) {

      cmm_assignment$feature <-
        select(extract(y_object, 'assignment'),
               dplyr::any_of(c('observation', 'node', 'clust_id')))

      if('node' %in% names(cmm_assignment$sample)) {

        cmm_assignment$feature <-
          set_names(cmm_assignment$feaure,
                    c('feature', 'feature_node', 'feature_clust'))

      } else {

        cmm_assignment$feature <-
          set_names(cmm_assignment$feature,
                    c('feature', 'feature_clust'))

      }


    }

    ## plotting data ---------

    if(is_combi_analysis(x_object)) {

      data <- model.frame(x_object)$observation

    } else {

      data <- model.frame(x_object)

    }

    data <- as_tibble(data)

    features <- names(data)

    data <- mutate(data,
                   sample = cmm_assignment$sample$sample)

    data <-
      tidyr::pivot_longer(data,
                          cols = all_of(features),
                          names_to = 'feature',
                          values_to = 'value')

    ## joining the data table with the cluster assignment information

    data <- left_join(data,
                      cmm_assignment$sample,
                      by = 'sample')

    if(!is.null(y_object)) {

      if(all(!features %in% cmm_assignment$feature$feature)) {

        stop(paste('Unable to retrieve the cluster assignment information ',
                   'or the clustering variables from the feature_clust_object.'),
             call. = FALSE)

      }

      data <- left_join(data,
                        cmm_assignment$feature,
                        by = 'feature')

    }

    ## plotting --------

    if(is_clust_analysis(x_object)) {

      base_plot <-
        ggplot(data,
               aes(x = reorder(sample,
                               as.numeric(factor(value))),
                   y = reorder(feature,
                               as.numeric(factor(value))),
                   fill = if(discrete_fill) factor(value) else value))

    } else {

      base_plot <-
        ggplot(data,
               aes(x = reorder(sample,
                               as.numeric(sample_node)),
                   y = reorder(feature,
                               as.numeric(factor(value))),
                   fill = if(discrete_fill) factor(value) else value))

    }

    if(!is.null(y_object)) {

      base_plot <- base_plot +
        ggplot2::facet_grid(feature_clust ~ sample_clust,
                            scales = 'free',
                            space = 'free')

    } else {

      base_plot <- base_plot +
        ggplot2::facet_grid(. ~ sample_clust,
                            scales = 'free',
                            space = 'free')

    }

    base_plot +
      ggplot2::geom_tile(color = line_color)

  }

#' @rdname ft_hm_single

  ft_hm_multi <- function(x_object,
                          line_color = NA,
                          discrete_fill = FALSE) {

    ## the entry control is made by an upstream function

    stopifnot(is.logical(discrete_fill))

    ## cluster assignment and plotting data ------

    clust_assignment <- extract(x_object, 'assignment')

    if(is_clust_analysis(x_object)) {

      data <- model.frame(x_object)

    } else {

      data <- model.frame(x_object)$observation

    }

    if(is.null(names(data))) {

      data <- set_names(data, paste0('layer_', 1:length(data)))

    }

    for(i in names(data)) {

      if(is.null(colnames(data[[i]]))) {

        colnames(data[[i]]) <-
          set_names(paste0(i, '_V', 1:ncol(data[[i]])))

      }

    }

    data <- map(data, as.data.frame)

    clust_features <- map(data, names)

    for(i in names(data)) {

      data[[i]] <- as_tibble(cbind(clust_assignment, data[[i]]))

      data[[i]] <-
        tidyr::pivot_longer(data[[i]],
                            cols = all_of(clust_features[[i]]),
                            values_to = 'value',
                            names_to = 'feature')

    }

    ## plotting -------

    if(discrete_fill) {

      hm_plots <-
        map(data,
            ~ggplot(.x,
                    aes(x = reorder(observation, value),
                        y = reorder(feature, value),
                        fill = factor(value))))

    } else {

      hm_plots <-
        map(data,
            ~ggplot(.x,
                    aes(x = reorder(observation, value),
                        y = reorder(feature, value),
                        fill = value)))

    }

    map(hm_plots,
        ~.x +
          ggplot2::geom_tile(color = line_color) +
          facet_grid(. ~ clust_id,
                     scales = 'free',
                     space = 'free'))

  }

# END ------
